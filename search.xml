<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Collections.sort()的使用]]></title>
    <url>%2F2018%2F05%2F18%2FCollections.sort()%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[String、Integer等基本类型已经实现了Comparable接口，可以直接使用Collections.sort()进行排序。 12345static List&lt;Integer&gt; intList = Arrays.asList(2, 3, 1);// ...Collections.sort(intList);// 输出 1,2,3 默认为正序排序，若想自定义排序，可以自己实现Comparator接口的compare方法。 1234567891011Coolections.sort(intList, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer 02) &#123; // 返回值为int，大于0表示正序，小于0表示逆序 return o1-o1; &#125; &#125;);// 输出 3,2,1 接下来是自定义类的排序，自定义一个类： 123456789101112131415161718192021222324252627public class Emp &#123; private int empno; private String ename; public int getEmpno() &#123; return empno; &#125; public void setEmpno(int empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public Emp(int empno, String ename) &#123; super(); this.empno = empno; this.ename = ename; &#125; @Override public String toString() &#123; return "empno:\t"+empno+"\tename:\t"+ename; &#125;&#125; 首先直接使用Collections.sort()进行排序 12345678910static List&lt;Emp&gt; empList; static &#123; Emp emp1 = new Emp(2,"Guan YunChang"); Emp emp2 = new Emp(3,"Zhang Fei"); Emp emp3 = new Emp(1,"Liu Bei"); empList = Arrays.asList(emp1,emp2,emp3); &#125;// ...Collections.sort(empList); 此时会报错： The method sort(List) in the type Collections is not applicable for the arguments (List) 意思是参数类型为List时，sort方法无法执行，原因是泛型没有继承Comparable接口。让Emp类实现Comparable接口并实现compareTo方法。 12345678910111213141516171819202122232425262728293031323334353637383940public class Emp implements Comparable&lt;Emp&gt;&#123; private int empno; private String ename; public int getEmpno() &#123; return empno; &#125; public void setEmpno(int empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public Emp(int empno, String ename) &#123; super(); this.empno = empno; this.ename = ename; &#125; @Override public int compareTo(@NonNull Emp another) &#123; // 按员工姓名逆序排序 return another.getEname().compareTo(this.getEname()); &#125; @Override public String toString() &#123; return "empno:\t"+empno+"\tename:\t"+ename; &#125;&#125;// 这时候调用Collections.sort(empList);// 输出// Zhang Fei// Liu Bei// Guan YunChang 或者使用第二个方法，调用Collections.sort(List, new Comparator() {});方法，并实现comparator的compare方式 123456789101112131415// 调用的时候Collections.sort(empList, new Comparator&lt;Emp&gt;() &#123; @Override public int compare(Emp e1, Emp e2) &#123; // 按员工姓名正序排序 return e1.getEname().compareTo(e2.getEname()); &#125; &#125;);// 输出// Guan YunChang// Liu Bei// Zhang Fei 总结： 1.对于String或Integer这些已经实现Comparable接口的类来说，可以直接使用Collections.sort方法传入list参数来实现默认方式（正序）排序； 2.如果不想使用默认方式（正序）排序，可以通过Collections.sort传入第二个参数类型为Comparator来自定义排序规则； 3.对于自定义类型(如本例子中的Emp)，如果想使用Collections.sort的方式一进行排序，可以通过实现Comparable接口的compareTo方法来进行，如果不实现，则参考第2点；]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Serialiable和Parceble的使用]]></title>
    <url>%2F2018%2F05%2F16%2FSerialiable%E5%92%8CParceble%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.Serializable1.使用1234567public class User implements Serializable &#123; private static final long serialVersionUID = 2737236472349823L; public int userId; public String userName; public boolean isMale;&#125; 类实现Serializable接口，即可自动实现序列化过程。 serialVersionUID标识可以指定，也可以不指定。serialVersionUID用来辅助序列化和反序列化过程，序列化后的数据中的serialVersionUID只有和当前类的serialVersionUID相同，才可以被正常反序列化。若不指定，编辑器根据当前类的结构自动生成hash值作为serialVersionUID，但若类发生变化时，比如增加或删除某些成员变量，系统自动重新计算hash值并赋值给serialVersionUID，这个时候当前类的serialVersionUID和序列化数据的serialVersionUID不一致，反序列会失败。（目前使用中好像没发现这个问题，为什么？？？） 2.重写序列化和反序列化过程1234567private void writeObject(java.io.ObjectOutputStream out) throws IOException &#123; // write 'this' to 'out'...&#125;private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException &#123; // populate the fields of 'this' from the data in 'in'...&#125; transient关键字:加上transient关键字的变量，不会被序列化。 2.Parcelable接口1.使用123456789101112131415161718192021222324252627282930313233343536373839404142434445public class User implements Parcelable &#123; public int userId; public String userName; public boolean isMale; public Book book; public User(int userId, String userName, boolean isMale) &#123; this.userId = userId; this.userName = userName; this.isMale = isMale; &#125; // 内容描述 public describeContents() &#123; return 0; &#125; // 序列化过程 public void writeToParcel(Parcel out, int flags) &#123; out.writeInt(userId); out.writeString(userName); out.writeInt(isMale ? 1 : 0 ); // boolean不能序列化，只能转化成int out.writeParcelable(book, 0); &#125; // 反序列化过程 public static final Parcelable.Creator&lt;User&gt; CREATOR = new Parcelable.Creator&lt;User&gt;() &#123; public User createFromParcel(Parcel in) &#123; return new User(in); &#125; public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; private User(Parcel in) &#123; userId = in.readInt(); userName = in.readString(); isMale = in.readInt() == 1; book = in.readParcelable(Thread.currentThread().getContextClassLoader()); &#125; &#125; 2.Parcelable的方法说明 方法 功能 标记位 createFromParcel(Parcel in) 从序列化的对象中创建原始对象 newArray(int size) 创建指定长度的原始对象数组 User(Parcel in) 从序列化的对象中创建原始对象 writeToParcel(Parcel out, int flags) 将当前对象写入序列化结构中，flags有0和1两种，为1标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0 PARCELABLE_WRITE_RETURN_VAL describeContents 返回当前对象的内容描述。如果含有文件描述符，返回1，否则返回0，几乎所有情况都返回0 CONTENTS_FILE_DESCRIPTOR 3.区别Serializable是Java中的序列化接口，使用起来简单但开销大，需要大量的I/0操作。Parcelable是Android中的序列化方式，更适合在Android平台上使用，虽然使用起来稍微麻烦，但是效率高。]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android gradle配置之manifestPlaceholders]]></title>
    <url>%2F2018%2F04%2F18%2FAndroid%20gradle%E9%85%8D%E7%BD%AE%E4%B9%8BmanifestPlaceholders%2F</url>
    <content type="text"><![CDATA[在开发应用中，有时候需要接入第三方sdk，而第三方sdk需要申请的key有时候又分为发布版和测试版，经常在测试开发的时候填写key，在发布版时忘记替换成发布版的key，导致发布版应用不能使用。这时候就需要给不同的版本配置不同key。 manifestPlaceholders就可以用来在gradle中为androidmanifest配置不同版本的key值。 在AndroidManifest.xml中: 123&lt;meta-data android:name="com.baidu.lbsapi.API_KEY" android:value="$&#123;BAIDU_LBS_API_KEY&#125;" /&gt; 在moudle的gradle文件中: 1234567891011buildTypes &#123; debug &#123; // .... manifestPlaceholders = [BAIDU_LBS_API_KEY: "debugkey"] &#125; release &#123; // .... manifestPlaceholders = [BAIDU_LBS_API_KEY: "releasekey"] &#125; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android系统应用信息中存储和缓存的计算方法]]></title>
    <url>%2F2018%2F02%2F27%2FAndroid%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E4%BF%A1%E6%81%AF%E4%B8%AD%E5%AD%98%E5%82%A8%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[进入设置界面，查看每个应用占用的存储空间时，有几样数据，计算方法如下：1. 应用，由三项相加而成 /data/data/com.myapp/lib，即so库文件夹大小 /data/app/com.myapp-1.apk，原始apk文件的复制 /data/dalvik-cache/data@app@com.myapp-1.apk@classes.dex，dalvik虚拟机对dex文件的缓存 2. USB存储(应用) 把程序装到（或移到）sd卡后的大小。/sdcard/Android/…，参考“应用”项 3. 数据 /data/data/com.myapp/目录大小 - cache子目录大小 - lib子目录大小 4. SD卡 /sdcard/Android/data/com.myapp/目录大小 - /sdcard/Android/data/com.myapp/cache目录大小 5. 缓存 /data/data/com.myapp/cache目录大小 + /sdcard/Android/data/com.myapp/cache目录大小]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Recycleview的简单使用]]></title>
    <url>%2F2018%2F02%2F07%2FRecycleview%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.xmlactivity_main.xml 12345678910111213141516171819202122232425262728&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.yangqiuyan.clickdemo.MainActivity"&gt; &lt;Button android:id="@+id/add_button" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="add" /&gt; &lt;Button android:id="@+id/remove_button" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/add_button" android:text="remove" /&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/my_recyclerview" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_below="@id/remove_button" android:scrollbars="vertical" /&gt;&lt;/RelativeLayout&gt; 2.MainActivity.java1234567891011121314151617181920212223242526272829303132333435363738394041424344class MainActivity : AppCompatActivity() &#123; var mMyAdapter: MyAdapter? = null var mLayoutManager: LinearLayoutManager? = null var mRecyclerView: RecyclerView? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initData() initView() initListener() &#125; fun initData() &#123; mMyAdapter = MyAdapter(this, getData()) mLayoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false) &#125; fun initView() &#123; mRecyclerView = findViewById(R.id.my_recyclerview) // 设置布局管理器 mRecyclerView!!.layoutManager = mLayoutManager // 设置适配器 mRecyclerView!!.adapter = mMyAdapter // 设置recycleview添加和移除动画 mRecyclerView!!.itemAnimator = DefaultItemAnimator() &#125; fun getData(): ArrayList&lt;String&gt; &#123; var data = ArrayList&lt;String&gt;() (0 until 25).mapTo(data) &#123; "item" + it &#125; return data &#125; fun initListener() &#123; add_button.setOnClickListener &#123; mMyAdapter!!.addNewItem() &#125; remove_button.setOnClickListener &#123; mMyAdapter!!.deleteitem() &#125; &#125;&#125; 3.MyAdapter.java12345678910111213141516171819202122232425262728293031323334353637383940414243class MyAdapter(context: Context, data: ArrayList&lt;String&gt;) : RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;() &#123; var context: Context? = null var data: ArrayList&lt;String&gt;? = null init &#123; this.context = context this.data = data &#125; override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): ViewHolder &#123; var view = LayoutInflater.from(context).inflate(R.layout.recycleview_item, parent, false) var viewHolder = ViewHolder(view) return viewHolder &#125; override fun getItemCount(): Int &#123; return data!!.size &#125; override fun onBindViewHolder(holder: ViewHolder?, position: Int) &#123; holder!!.textview!!.text = data!![position] &#125; class ViewHolder(itemView: View?) : RecyclerView.ViewHolder(itemView) &#123; var textview: TextView? = null init &#123; textview = itemView?.findViewById(R.id.textview) &#125; &#125; fun addNewItem() &#123; data!!.add(1, "new item") notifyItemInserted(1) &#125; fun deleteitem() &#123; data!!.removeAt(1) notifyItemRemoved(1) &#125;&#125; 每个item的布局文件这里就不贴出来。]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[华为手机兼容性处理]]></title>
    <url>%2F2017%2F12%2F12%2Fandroid-%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%85%BC%E5%AE%B9%E6%80%A7%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.华为Toast显示因为华为系统对Toast进行了定制，所以如果两个触发时机非常接近的Toast，华为只会显示一个。例: 12Toast.makeText(this, "this is toast 1", Toast.LENGTH_SHORT).show();Toast.makeText(this, "this is toast 2", Toast.LENGTH_Long).show(); 则华为手机只会显示最后一个toast。 2. 背景绘制最近在做项目的时候，需要给一个Fragment的背景绘制上倾斜的水印，水印的绘制通过自定义drawable，重写draw()方法生成一张drawable，然后用setBackground()设置为背景。 水印生成的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class WarterMarkDrawable extends Drawable &#123; Context context; String markStr = ""; int textColor = Color.BLACK; int textSize = 30; int backgroundColor = Color.WHITE; int rotate = -30; int alpha = 41; int density = 10; private Paint paint = new Paint(); public WarterMarkDrawable(Context context, String watermark) &#123; this.context = context; this.markStr = watermark; this.textColor = ContextCompat.getColor(context, R.color.water_mark_color); this.textSize = 42; this.backgroundColor = ContextCompat.getColor(context, R.color.background_6_0); this.rotate = -20; this.density = 7; &#125; @Override public void draw(@NonNull Canvas canvas) &#123; int width = getBounds().right + 200; int height = getBounds().bottom + 200; canvas.drawColor(backgroundColor); paint.setColor(textColor); paint.setAntiAlias(true); paint.setTextSize(textSize); canvas.rotate(rotate); canvas.save(); float textWidth = paint.measureText(markStr); int index = 0; int sheight = 100; float swidth = textWidth * 2 + 20; for (int positionY = sheight; positionY &lt;= height; positionY += sheight) &#123; float fromX = -width + (index++ % 2) * textWidth; for (float positionX = fromX; positionX &lt; width; positionX += swidth) &#123; canvas.drawText(markStr, positionX, positionY, paint); &#125; &#125; canvas.restore(); &#125; @Override public void setAlpha(int i) &#123; &#125; @Override public void setColorFilter(@Nullable ColorFilter colorFilter) &#123; &#125; @Override public int getOpacity() &#123; return PixelFormat.UNKNOWN; &#125;&#125; 一开始这方法生成的drawable都没有问题，也没有造成内存泄露。直到遇到了华为MT7 4.4系统，用这方法生成水印背景，导致所有设置该背景的Fragment内容全部变成倾斜。在前辈的帮助下，定位问题，可能是在draw()方法里面绘制背景的时候，用canvas.rotate(rotate);对整个画布进行旋转，华为MT7 4.4系统应该把所有的内容(包括listview等)都绘制在canvas上面，是得在进行选择的时候，不是对该背景的canvas进行旋转，而是旋转了所有的view。 更新：经过多个机型匹配发现，这是Android4.4手机系统都会有的问题 前辈说在onDraw()函数加canvas.save()和canvas.restore()可以解决问题，还没验证 对生成自定义drawable进行了改造。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class WarterMarkDrawable extends Drawable &#123; Context context; String markStr = ""; int textColor = Color.BLACK; int textSize = 30; int backgroundColor = Color.WHITE; int rotate = -30; int alpha = 41; int density = 10; private Paint paint = new Paint(); Bitmap bitmap = null; public WarterMarkDrawable(Context context, String watermark) &#123; this.context = context; this.markStr = watermark; this.textColor = ContextCompat.getColor(context, R.color.water_mark_color); this.textSize = 42; this.backgroundColor = ContextCompat.getColor(context, R.color.background_6_0); this.rotate = -20; this.density = 7; &#125; public WarterMarkDrawable(Context context, String watermark, Bitmap bitmap) &#123; this.context = context; this.markStr = watermark; this.textColor = ContextCompat.getColor(context, R.color.water_mark_color); this.textSize = 42; this.backgroundColor = ContextCompat.getColor(context, R.color.background_6_0); this.rotate = -20; this.density = 7; this.bitmap = bitmap; &#125; @Override public void draw(@NonNull Canvas canvas) &#123; int width; int height; // 只有mt7才会进入该方法 在外面将水平drawable转换成bitmap后再旋转bitmap 绘制在canvas上 if (bitmap != null) &#123; Matrix matrix = new Matrix(); // 根据中点旋转 matrix.postRotate(rotate, bitmap.getWidth() / 2, bitmap.getHeight() / 2); canvas.drawBitmap(bitmap, matrix, paint); &#125; else &#123; // 华为MT7不能直接旋转画布 先生成一个水平的不旋转的drawable if (DeviceInfo.MODEL.getModel().contains("HUAWEI MT7")) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); width = wm.getDefaultDisplay().getWidth() + 200; height = wm.getDefaultDisplay().getHeight() + 200; &#125; else &#123; // 普通系统走正常的生成水印代码 width = getBounds().right + 200; height = getBounds().bottom + 200; canvas.rotate(rotate); &#125; canvas.drawColor(backgroundColor); paint.setColor(textColor); paint.setAntiAlias(true); paint.setTextSize(textSize); canvas.save(); float textWidth = paint.measureText(markStr); int index = 0; int sheight = 100; float swidth = textWidth * 2 + 20; for (int positionY = sheight; positionY &lt;= height; positionY += sheight) &#123; float fromX = -width + (index++ % 2) * textWidth; for (float positionX = fromX; positionX &lt; width; positionX += swidth) &#123; canvas.drawText(markStr, positionX, positionY, paint); &#125; &#125; canvas.restore(); &#125; &#125; @Override public void setAlpha(int i) &#123; &#125; @Override public void setColorFilter(@Nullable ColorFilter colorFilter) &#123; &#125; @Override public int getOpacity() &#123; return PixelFormat.UNKNOWN; &#125;&#125; 增加了一个bitmap成员，在华为MT7 系统上，先生成一个不旋转的水平的水印背景drawable，将改drawable转化成bitmap，然后对该bitmap进行旋转，绘制在canvas上，避免了旋转canvas。 在外围调用的时候 12345678910111213141516// 先生成一张drawable 若是华为MT7系统 则生成的是不旋转的水平drawableWarterMarkDrawable waterDrawable = new WarterMarkDrawable(context, watermark);// 华为MT7不能直接在画布上旋转if (DeviceInfo.MODEL.getModel().contains("HUAWEI MT7")) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); // 将drawable转化成bitmap int width = wm.getDefaultDisplay().getWidth() + 200; int height = wm.getDefaultDisplay().getHeight() + 200; Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); waterDrawable.draw(canvas); // 再生成一次drawable，这次传入bitmap后，会将改bitamp选择并绘制在canvas上，而不是选择canvas WarterMarkDrawable bitmapDrawable = new WarterMarkDrawable(context, watermark, bitmap);&#125; // ... 将waterDrawable 或 bitmapDrawable设置成view的背景，即完成水印背景的绘制 总结：简直被华为系统坑爆了。。。]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[android string资源的用法]]></title>
    <url>%2F2017%2F11%2F28%2Fandroid-string%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Android string的用法 原文地址：%1$s %1$d Android string 1.整型例如”我今年23岁了”，可以在string.xml文件中这样写 1&lt;string name="old"&gt;我今年%1$d岁了&lt;/string&gt; 在程序中这样使用 12String str = getResource().getString(R.string.old);String year = String.format(str, 23); 将%1$d替换为23。%1$d的意思为，name=”old”这个字符串中，第一个参数为整型。如果一个string资源中，有两个替换的部分，则第二个写为%2$(X)，X为整型或string型，以此类推。 2.string型例如，”我的名字叫李四，我来自北京”，在string.xml资源文件中，可以写成: 1&lt;string name="info"&gt;我的名字叫%1$s,我来自%2$s。&lt;/string&gt; 在程序中写成: 1String info = String.format(getResource().getString(R.string.info), "李四","北京");]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java enum的用法]]></title>
    <url>%2F2017%2F11%2F21%2Fjava-enum%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java enum的用法 原文地址：Java enum的用法 1.主要方法 name()：获取定义的枚举值的名称 ordinal()：获取枚举值的位置，位置从0开始 2.用法1). 常量123public enum Color&#123; RED,GREEN,BLANK,YELLOW&#125; 2). 向枚举中添加新方法如果打算自定义自己的方法，必须在enum实例序列的最后一个添加一个分号，而且Java要求必须先定义enum实例。 123456789101112131415161718192021222324252627282930313233public enum Color&#123; RED("红色",1), GREEN("绿色",2), BLANK("白色"，3), YELLO("黄色", 4); // 成员变量 private String name; private int index; // 构造方法 private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; // 普通方法 public static String getName(int index) &#123; for(Color c : Color.values()) &#123; if(c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; // 构造器 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kotlin实战2 — 类和属性]]></title>
    <url>%2F2017%2F11%2F20%2FKotlin%E5%AE%9E%E6%88%982-%E7%B1%BB%E5%92%8C%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Kotlin实战2 — 类和属性1. 属性类的概念就是把数据处理和处理数据的代码封装成一个单一的实体。在Java中，数据存储在字段中，通常还是私有的。如果想让类的使用者访问到数据，要提供访问器方法，一个setter，一个getter。 在Java中，字段和其访问器的组合常常被叫做属性。在Kotlin中，类声明一个属性和声明一个变量一样:使用val和var关键字。 1234class Person( val name: String var isMarried: Boolean) 当我们声明属性的时候，就声明了对应的构造器（val属性只有getter构造器，而var属性有setter和getter）。Kotlin的Person隐藏了和原始Java代码相同的实现，所以无论在Java代码中，还是Kotlin代码中，都可以用同样的方式使用这个类。 123456// javaPerson person = new Person("Bob", true);System.out.prientln(person.getName);// kotlinval person = Person("Bob", false) // 调用构造方法不需要关键字newprintln(person.name) // 直接访问属性，但调用的是getter 2. 自定义访问器1234567class Rectangle(val height: Int, val width: Int) &#123; val isSquare: Boolean get() &#123; return height == width; &#125;&#125;// or get() = height == width]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kotlin实战1 — 函数和变量]]></title>
    <url>%2F2017%2F11%2F19%2FKotlin%E5%AE%9E%E6%88%981%2F</url>
    <content type="text"><![CDATA[Kotlin实战1 — 函数和变量1.函数123fun max(a: Int, b: Int): Int &#123; return if (a &gt; b) a else b&#125; ​ 函数声明以关键字fun开始，函数名紧随其后，括号括起来参数列表，参数列表后面跟着返回类型，与参数用一个冒号隔开。 在Kotlin中，if是表达式，而不是语句。表达式：表达式由变量，操作符和方法调用组成，表达式的返回值类型由表达式中的元素（如操作符，变量等）决定如：a = 1。语句：是完整的执行单元，如：赋值表达式、所有使用 ++ 或者 --的变量、方法引用、创建对象的表达式，如：a++; 表达式函数体1fun max(a: Int, b: Int): Int = if(a &gt; b) a els b 如果函数体写在花括号中，我们说这个函数有代码块体，如果直接返回了一个表达式，它就有表达式体。对于表达式函数体来说，函数还可以省略返回值类型，编译器会分析作为函数体的表达式，并把它的类型作为函数的返回值类型，这种分析被称为类型推导。 2.变量在Kotlin中，声明变量以关键字开始，然后是变量名，最后可以加上类型（也可以不加上）。 12val question = "the ultimate question of life,th universe,and everything"val answer = 42 如果变量没有初始化器，就需要显示的指定它的类型 12val answer: Intanswer = 42 可变变量和不可变变量 val — 不可变引用。使用val声明的变量不能在初始化之后再次赋值，它对应的是Java的final变量。 var — 可变引用。这种变量的值可以被改变，对应普通（非final）的Java变量 val引用自身是不可变的，但它指向的对象可能是可变的。例如： 12val languages = arrayListOf("Java")languages.add("Android") 3.字符串模板1234fun main(args: Array&lt;String&gt;) &#123; val name = if(args.size &gt; 0) args[0] : "Kotlin" println("hello, $name!")&#125; Kotlin可以在字符串字面值中引用局部变量，只需要在变量名称前面加上字符$。等价于Java中的字符串连接(“hello, “ + name + “!”)。还可以使用更复杂的表达式： 12345fun main(args: Array&lt;String&gt;) &#123; if(args.size &gt; 0) &#123; printl("hello, $&#123;args[0]&#125;!") &#125;&#125; 还可以在双引号中直接嵌套双引号，只要它们处于某个表达式的范围内（即花括号内）。 123fun main(args: Array&lt;String&gt;) &#123; println("hello, $&#123;if (args.size &gt; 0) args[0] else "someone"&#125;!")&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[first blog]]></title>
    <url>%2F2017%2F11%2F17%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[A test atricul for my blog I’n learning how to do it.]]></content>
  </entry>
</search>
